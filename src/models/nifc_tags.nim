# Generated by tools/gen_tags.nim from doc/tags.md. DO NOT EDIT!

type
  NifcExpr* = enum
    NoNifcExpr
    ErrC = (1, "err")  ## indicates an error
    SufC = (2, "suf")  ## literal with suffix annotation
    AtC = (3, "at")  ## array indexing operation
    DerefC = (4, "deref")  ## pointer deref operation
    DotC = (5, "dot")  ## object field selection
    PatC = (6, "pat")  ## pointer indexing operation
    ParC = (7, "par")  ## syntactic parenthesis
    AddrC = (8, "addr")  ## address of operation
    NilC = (9, "nil")  ## nil pointer value
    InfC = (10, "inf")  ## positive infinity floating point value
    NeginfC = (11, "neginf")  ## negative infinity floating point value
    NanC = (12, "nan")  ## NaN floating point value
    FalseC = (13, "false")  ## boolean `false` value
    TrueC = (14, "true")  ## boolean `true` value
    AndC = (15, "and")  ## boolean `and` operation
    OrC = (16, "or")  ## boolean `or` operation
    NotC = (17, "not")  ## boolean `not` operation
    NegC = (18, "neg")  ## negation operation
    SizeofC = (19, "sizeof")  ## `sizeof` operation
    AlignofC = (20, "alignof")  ## `alignof` operation
    OffsetofC = (21, "offsetof")  ## `offsetof` operation
    OconstrC = (22, "oconstr")  ## object constructor
    AconstrC = (23, "aconstr")  ## array constructor
    AddC = (25, "add")  ##
    SubC = (26, "sub")  ##
    MulC = (27, "mul")  ##
    DivC = (28, "div")  ##
    ModC = (29, "mod")  ##
    ShrC = (30, "shr")  ##
    ShlC = (31, "shl")  ##
    BitandC = (32, "bitand")  ##
    BitorC = (33, "bitor")  ##
    BitxorC = (34, "bitxor")  ##
    BitnotC = (35, "bitnot")  ##
    EqC = (36, "eq")  ##
    NeqC = (37, "neq")  ##
    LeC = (38, "le")  ##
    LtC = (39, "lt")  ##
    CastC = (40, "cast")  ##
    ConvC = (41, "conv")  ## type conversion
    CallC = (42, "call")  ## call operation
  NifcStmt* = enum
    NoNifcStmt
    GvarS = (46, "gvar")  ## global variable declaration
    TvarS = (47, "tvar")  ## thread local variable declaration
    VarS = (48, "var")  ## variable declaration
    ConstS = (50, "const")  ## const variable declaration
    ProcS = (57, "proc")  ## proc declaration
    TypeS = (64, "type")  ## type declaration
    EmitS = (68, "emit")  ## emit statement
    AsgnS = (69, "asgn")  ## assignment statement
    ScopeS = (70, "scope")  ## explicit scope annotation, like `stmts`
    IfS = (71, "if")  ## if statement header
    BreakS = (75, "break")  ## `break` statement
    WhileS = (78, "while")  ## `while` statement
    CaseS = (79, "case")  ## `case` statement
    LabS = (81, "lab")  ## label, target of a `jmp` instruction
    JmpS = (82, "jmp")  ## jump/goto instruction
    RetS = (83, "ret")  ## `return` instruction
    StmtsS = (85, "stmts")  ## list of statements
    ImpS = (122, "imp")  ## import declaration
    InclS = (124, "incl")  ## `#include` statement or `incl` set operation
    ImportS = (127, "import")  ## `import` statement
    FromS = (128, "from")  ## `from` statement
    ImportexceptS = (129, "importexcept")  ## `importexcept` statement
    ExportS = (130, "export")  ## `export` statement
    CommentS = (131, "comment")  ## `comment` statement
    DiscardS = (132, "discard")  ## `discard` statement
    TryS = (133, "try")  ## `try` statement
    RaiseS = (134, "raise")  ## `raise` statement
    OnerrS = (135, "onerr")  ## error handling statement
  NifcType* = enum
    NoNifcType
    ParamsT = (86, "params")  ## list of proc parameters, also used as a "proc type"
    UnionT = (87, "union")  ## union declaration
    ObjectT = (88, "object")  ## object type declaration
    EnumT = (89, "enum")  ## enum type declaration
    ProctypeT = (90, "proctype")  ## proc type declaration (soon obsolete, use params instead)
    IT = (94, "i")  ## `int` builtin type
    UT = (95, "u")  ## `uint` builtin type
    FT = (96, "f")  ## `float` builtin type
    CT = (97, "c")  ## `char` builtin type
    BoolT = (98, "bool")  ## `bool` builtin type
    VoidT = (99, "void")  ## `void` return type
    PtrT = (100, "ptr")  ## `ptr` type contructor
    ArrayT = (101, "array")  ## `array` type constructor
    FlexarrayT = (102, "flexarray")  ## `flexarray` type constructor
    AptrT = (103, "aptr")  ## "pointer to array of" type constructor
  NifcOther* = enum
    NoNifcSubstructure
    KvU = (24, "kv")  ## key-value pair
    RangeU = (44, "range")  ## `(range a b)` construct
    RangesU = (45, "ranges")  ##
    ParamU = (49, "param")  ## parameter declaration
    TypevarU = (54, "typevar")  ## type variable declaration
    EfldU = (55, "efld")  ## enum field declaration
    FldU = (56, "fld")  ## field declaration
    ElifU = (73, "elif")  ## pair of (condition, action)
    ElseU = (74, "else")  ## `else` action
    OfU = (80, "of")  ## `of` branch within a `case` statement
    AttrU = (114, "attr")  ## general attribute annoation
    PragmasU = (118, "pragmas")  ## begin of pragma section
  NifcPragma* = enum
    NoNifcPragma
    InlineP = (112, "inline")  ## `inline` proc annotation
    NoinlineP = (113, "noinline")  ## `noinline` proc annotation
    VarargsP = (115, "varargs")  ## `varargs` proc annotation
    WasP = (116, "was")  ##
    SelectanyP = (117, "selectany")  ##
    AlignP = (119, "align")  ##
    BitsP = (120, "bits")  ##
    VectorP = (121, "vector")  ##
    NodeclP = (123, "nodecl")  ## `nodecl` annotation
    RaisesP = (136, "raises")  ## proc annotation
    ErrsP = (137, "errs")  ## proc annotation
    StaticP = (138, "static")  ## `static` type or annotation
  NifcTypeQualifier* = enum
    NoQualifier
    AtomicQ = (91, "atomic")  ## `atomic` type qualifier for NIFC
    RoQ = (92, "ro")  ## `readonly` (= `const`) type qualifier for NIFC
    RestrictQ = (93, "restrict")  ## type qualifier for NIFC
