# Generated by tools/gen_tags.nim from doc/tags.md. DO NOT EDIT!


type
  NimonyExpr* = enum
    NoExpr
    ErrX = (1, "err")  ## indicates an error
    SufX = (2, "suf")  ## literal with suffix annotation
    AtX = (3, "at")  ## array indexing operation
    DerefX = (4, "deref")  ## pointer deref operation
    DotX = (5, "dot")  ## object field selection
    PatX = (6, "pat")  ## pointer indexing operation
    ParX = (7, "par")  ## syntactic parenthesis
    AddrX = (8, "addr")  ## address of operation
    NilX = (9, "nil")  ## nil pointer value
    InfX = (10, "inf")  ## positive infinity floating point value
    NeginfX = (11, "neginf")  ## negative infinity floating point value
    NanX = (12, "nan")  ## NaN floating point value
    FalseX = (13, "false")  ## boolean `false` value
    TrueX = (14, "true")  ## boolean `true` value
    AndX = (15, "and")  ## boolean `and` operation
    OrX = (16, "or")  ## boolean `or` operation
    NotX = (17, "not")  ## boolean `not` operation
    NegX = (18, "neg")  ## negation operation
    SizeofX = (19, "sizeof")  ## `sizeof` operation
    AlignofX = (20, "alignof")  ## `alignof` operation
    OffsetofX = (21, "offsetof")  ## `offsetof` operation
    ObjX = (23, "obj")  ## object constructor
    ArrX = (25, "arr")  ## array constructor
    BracketX = (26, "bracket")  ## untyped array constructor
    CurlyX = (27, "curly")  ## untyped set constructor
    AddX = (29, "add")
    SubX = (30, "sub")
    MulX = (31, "mul")
    DivX = (32, "div")
    ModX = (33, "mod")
    ShrX = (34, "shr")
    ShlX = (35, "shl")
    BitandX = (36, "bitand")
    BitorX = (37, "bitor")
    BitxorX = (38, "bitxor")
    BitnotX = (39, "bitnot")
    EqX = (40, "eq")
    NeqX = (41, "neq")
    LeX = (42, "le")
    LtX = (43, "lt")
    CastX = (44, "cast")
    ConvX = (45, "conv")  ## type conversion
    CallX = (46, "call")  ## call operation
    CmdX = (47, "cmd")  ## command operation
    CchoiceX = (71, "cchoice")  ## closed choice
    OchoiceX = (72, "ochoice")  ## open choice
    QuotedX = (199, "quoted")  ## name in backticks
    HderefX = (200, "hderef")  ## hidden pointer deref operation
    DdotX = (201, "ddot")  ## deref dot
    HaddrX = (202, "haddr")  ## hidden address of operation
    NewobjX = (203, "newobj")  ## new object constructor
    TupX = (204, "tup")  ## tuple constructor
    SetX = (205, "set")  ## set constructor
    AshrX = (206, "ashr")
    OconvX = (207, "oconv")  ## object conversion
    HconvX = (208, "hconv")  ## hidden basic type conversion
    DconvX = (209, "dconv")  ## conversion between `distinct` types
    CallstrlitX = (210, "callstrlit")
    InfixX = (211, "infix")
    PrefixX = (212, "prefix")
    HcallX = (213, "hcall")  ## hidden converter call
    CompilesX = (214, "compiles")
    DeclaredX = (215, "declared")
    DefinedX = (216, "defined")
    HighX = (217, "high")
    LowX = (218, "low")
    TypeofX = (219, "typeof")
    UnpackX = (220, "unpack")
    EnumtostrX = (221, "enumtostr")
    IsmainmoduleX = (222, "ismainmodule")
    DefaultobjX = (223, "defaultobj")
    DefaulttupX = (224, "defaulttup")
    ExprX = (225, "expr")
    ArratX = (226, "arrat")
    TupatX = (227, "tupat")
    PlussetX = (228, "plusset")
    MinussetX = (229, "minusset")
    MulsetX = (230, "mulset")
    XorsetX = (231, "xorset")
    EqsetX = (232, "eqset")
    LesetX = (233, "leset")
    LtsetX = (234, "ltset")
    InsetX = (235, "inset")
    CardX = (236, "card")
    EmoveX = (237, "emove")
    DestroyX = (238, "destroy")
    DupX = (239, "dup")
    CopyX = (240, "copy")
    WasmovedX = (241, "wasmoved")
    SinkhX = (242, "sinkh")
    TraceX = (243, "trace")

proc rawTagIsNimonyExpr*(raw: uint32): bool {.inline.} =
  raw <= 255'u32 and raw.uint8 in {1'u8, 2'u8, 3'u8, 4'u8, 5'u8, 6'u8, 7'u8, 8'u8, 9'u8, 10'u8, 11'u8, 12'u8, 13'u8, 14'u8, 15'u8, 16'u8, 17'u8, 18'u8, 19'u8, 20'u8, 21'u8, 23'u8, 25'u8, 26'u8, 27'u8, 29'u8, 30'u8, 31'u8, 32'u8, 33'u8, 34'u8, 35'u8, 36'u8, 37'u8, 38'u8, 39'u8, 40'u8, 41'u8, 42'u8, 43'u8, 44'u8, 45'u8, 46'u8, 47'u8, 71'u8, 72'u8, 199'u8, 200'u8, 201'u8, 202'u8, 203'u8, 204'u8, 205'u8, 206'u8, 207'u8, 208'u8, 209'u8, 210'u8, 211'u8, 212'u8, 213'u8, 214'u8, 215'u8, 216'u8, 217'u8, 218'u8, 219'u8, 220'u8, 221'u8, 222'u8, 223'u8, 224'u8, 225'u8, 226'u8, 227'u8, 228'u8, 229'u8, 230'u8, 231'u8, 232'u8, 233'u8, 234'u8, 235'u8, 236'u8, 237'u8, 238'u8, 239'u8, 240'u8, 241'u8, 242'u8, 243'u8}

type
  NimonyStmt* = enum
    NoStmt
    CallS = (46, "call")  ## call operation
    CmdS = (47, "cmd")  ## command operation
    VarS = (52, "var")  ## variable declaration
    ConstS = (54, "const")  ## const variable declaration
    ResultS = (55, "result")  ## result variable declaration
    LetS = (56, "let")  ## let variable declaration
    CursorS = (57, "cursor")  ## cursor variable declaration
    ProcS = (61, "proc")  ## proc declaration
    FuncS = (62, "func")  ## function declaration
    IteratorS = (63, "iterator")  ## iterator declaration
    ConverterS = (64, "converter")  ## converter declaration
    MethodS = (65, "method")  ## method declaration
    MacroS = (66, "macro")  ## macro declaration
    TemplateS = (67, "template")  ## template declaration
    TypeS = (68, "type")  ## type declaration
    BlockS = (69, "block")  ## block declaration
    EmitS = (73, "emit")  ## emit statement
    AsgnS = (74, "asgn")  ## assignment statement
    ScopeS = (75, "scope")  ## explicit scope annotation, like `stmts`
    IfS = (76, "if")  ## if statement header
    WhenS = (77, "when")  ## when statement header
    BreakS = (81, "break")  ## `break` statement
    ContinueS = (82, "continue")  ## `continue` statement
    ForS = (83, "for")  ## for statement
    WhileS = (84, "while")  ## `while` statement
    CaseS = (85, "case")  ## `case` statement
    RetS = (89, "ret")  ## `return` instruction
    YldS = (90, "yld")  ## yield statement
    StmtsS = (91, "stmts")  ## list of statements
    PragmasS = (124, "pragmas")  ## begin of pragma section
    InclS = (130, "incl")  ## `#include` statement or `incl` set operation
    ExclS = (131, "excl")  ## `excl` set operation
    IncludeS = (132, "include")  ## `include` statement
    ImportS = (133, "import")  ## `import` statement
    FromS = (134, "from")  ## `from` statement
    ImportexceptS = (135, "importexcept")  ## `importexcept` statement
    ExportS = (136, "export")  ## `export` statement
    CommentS = (137, "comment")  ## `comment` statement
    DiscardS = (138, "discard")  ## `discard` statement
    TryS = (139, "try")  ## `try` statement
    RaiseS = (140, "raise")  ## `raise` statement

proc rawTagIsNimonyStmt*(raw: uint32): bool {.inline.} =
  raw <= 255'u32 and raw.uint8 in {46'u8, 47'u8, 52'u8, 54'u8, 55'u8, 56'u8, 57'u8, 61'u8, 62'u8, 63'u8, 64'u8, 65'u8, 66'u8, 67'u8, 68'u8, 69'u8, 73'u8, 74'u8, 75'u8, 76'u8, 77'u8, 81'u8, 82'u8, 83'u8, 84'u8, 85'u8, 89'u8, 90'u8, 91'u8, 124'u8, 130'u8, 131'u8, 132'u8, 133'u8, 134'u8, 135'u8, 136'u8, 137'u8, 138'u8, 139'u8, 140'u8}

type
  NimonyType* = enum
    NoType
    ErrT = (1, "err")  ## indicates an error
    AtT = (3, "at")  ## array indexing operation
    AndT = (15, "and")  ## boolean `and` operation
    OrT = (16, "or")  ## boolean `or` operation
    NotT = (17, "not")  ## boolean `not` operation
    IteratorT = (63, "iterator")  ## iterator declaration
    ParamsT = (92, "params")  ## list of proc parameters, also used as a "proc type"
    ObjectT = (94, "object")  ## object type declaration
    EnumT = (95, "enum")  ## enum type declaration
    ProctypeT = (96, "proctype")  ## proc type declaration (soon obsolete, use params instead)
    IT = (100, "i")  ## `int` builtin type
    UT = (101, "u")  ## `uint` builtin type
    FT = (102, "f")  ## `float` builtin type
    CT = (103, "c")  ## `char` builtin type
    BoolT = (104, "bool")  ## `bool` builtin type
    VoidT = (105, "void")  ## `void` return type
    PtrT = (106, "ptr")  ## `ptr` type contructor
    ArrayT = (107, "array")  ## `array` type constructor
    VarargsT = (121, "varargs")  ## `varargs` proc annotation
    StaticT = (144, "static")  ## `static` type or annotation
    RefobjT = (153, "refobj")  ## `ref object` type
    PtrobjT = (154, "ptrobj")  ## `ptr object` type
    TupleT = (155, "tuple")  ## `tuple` type
    OnumT = (156, "onum")  ## enum with holes type
    RefT = (157, "ref")  ## `ref` type
    MutT = (158, "mut")  ## `mut` type
    OutT = (159, "out")  ## `out` type
    LentT = (160, "lent")  ## `lent` type
    SinkT = (161, "sink")  ## `sink` type
    NiltT = (162, "nilt")  ## `nilt` type
    ConceptT = (163, "concept")  ## `concept` type
    DistinctT = (164, "distinct")  ## `distinct` type
    ItertypeT = (165, "itertype")  ## `itertype` type
    RangetypeT = (166, "rangetype")  ## `rangetype` type
    UarrayT = (167, "uarray")  ## `uarray` type
    OpenarrayT = (168, "openarray")  ## `openarray` type
    SettT = (169, "sett")  ## `sett` type
    AutoT = (170, "auto")  ## `auto` type
    SymkindT = (171, "symkind")  ## `symkind` type
    TypekindT = (172, "typekind")  ## `typekind` type
    TypedescT = (173, "typedesc")  ## `typedesc` type
    UntypedT = (174, "untyped")  ## `untyped` type
    TypedT = (175, "typed")  ## `typed` type
    CstringT = (176, "cstring")  ## `cstring` type
    PointerT = (177, "pointer")  ## `pointer` type
    OrdinalT = (178, "ordinal")  ## `ordinal` type

proc rawTagIsNimonyType*(raw: uint32): bool {.inline.} =
  raw <= 255'u32 and raw.uint8 in {1'u8, 3'u8, 15'u8, 16'u8, 17'u8, 63'u8, 92'u8, 94'u8, 95'u8, 96'u8, 100'u8, 101'u8, 102'u8, 103'u8, 104'u8, 105'u8, 106'u8, 107'u8, 121'u8, 144'u8, 153'u8, 154'u8, 155'u8, 156'u8, 157'u8, 158'u8, 159'u8, 160'u8, 161'u8, 162'u8, 163'u8, 164'u8, 165'u8, 166'u8, 167'u8, 168'u8, 169'u8, 170'u8, 171'u8, 172'u8, 173'u8, 174'u8, 175'u8, 176'u8, 177'u8, 178'u8}

type
  NimonyOther* = enum
    NoSub
    KvU = (28, "kv")  ## key-value pair
    RangeU = (48, "range")  ## `(range a b)` construct
    RangesU = (49, "ranges")
    ParamU = (53, "param")  ## parameter declaration
    TypevarU = (58, "typevar")  ## type variable declaration
    EfldU = (59, "efld")  ## enum field declaration
    FldU = (60, "fld")  ## field declaration
    ElifU = (78, "elif")  ## pair of (condition, action)
    ElseU = (79, "else")  ## `else` action
    TypevarsU = (80, "typevars")  ## type variable/generic parameters
    OfU = (86, "of")  ## `of` branch within a `case` statement
    PragmasU = (124, "pragmas")  ## begin of pragma section
    UnpackflatU = (149, "unpackflat")  ## unpack into flat variable list
    UnpacktupU = (150, "unpacktup")  ## unpack tuple
    ExceptU = (151, "except")  ## except subsection
    FinU = (152, "fin")  ## finally subsection

proc rawTagIsNimonyOther*(raw: uint32): bool {.inline.} =
  raw <= 255'u32 and raw.uint8 in {28'u8, 48'u8, 49'u8, 53'u8, 58'u8, 59'u8, 60'u8, 78'u8, 79'u8, 80'u8, 86'u8, 124'u8, 149'u8, 150'u8, 151'u8, 152'u8}

type
  NimonyPragma* = enum
    NoPragma
    EmitP = (73, "emit")  ## emit statement
    InlineP = (118, "inline")  ## `inline` proc annotation
    NoinlineP = (119, "noinline")  ## `noinline` proc annotation
    VarargsP = (121, "varargs")  ## `varargs` proc annotation
    SelectanyP = (123, "selectany")
    AlignP = (125, "align")
    BitsP = (126, "bits")
    NodeclP = (129, "nodecl")  ## `nodecl` annotation
    RaisesP = (142, "raises")  ## proc annotation
    MagicP = (179, "magic")  ## `magic` pragma
    ImportcP = (180, "importc")  ## `importc` pragma
    ImportcppP = (181, "importcpp")  ## `importcpp` pragma
    ExportcP = (182, "exportc")  ## `exportc` pragma
    HeaderP = (183, "header")  ## `header` pragma
    ThreadvarP = (184, "threadvar")  ## `threadvar` pragma
    GlobalP = (185, "global")  ## `global` pragma
    DiscardableP = (186, "discardable")  ## `discardable` pragma
    NoreturnP = (187, "noreturn")  ## `noreturn` pragma
    BorrowP = (188, "borrow")  ## `borrow` pragma
    NoSideEffectP = (189, "noSideEffect")  ## `noSideEffect` pragma
    NodestroyP = (190, "nodestroy")  ## `nodestroy` pragma
    PluginP = (191, "plugin")  ## `plugin` pragma
    BycopyP = (192, "bycopy")  ## `bycopy` pragma
    ByrefP = (193, "byref")  ## `byref` pragma
    NoinitP = (194, "noinit")  ## `noinit` pragma
    RequiresP = (195, "requires")  ## `requires` pragma
    EnsuresP = (196, "ensures")  ## `ensures` pragma
    BuildP = (197, "build")  ## `build` pragma
    StringP = (198, "string")  ## `string` pragma

proc rawTagIsNimonyPragma*(raw: uint32): bool {.inline.} =
  raw <= 255'u32 and raw.uint8 in {73'u8, 118'u8, 119'u8, 121'u8, 123'u8, 125'u8, 126'u8, 129'u8, 142'u8, 179'u8, 180'u8, 181'u8, 182'u8, 183'u8, 184'u8, 185'u8, 186'u8, 187'u8, 188'u8, 189'u8, 190'u8, 191'u8, 192'u8, 193'u8, 194'u8, 195'u8, 196'u8, 197'u8, 198'u8}

type
  NimonySym* = enum
    NoSym
    VarY = (52, "var")  ## variable declaration
    ParamY = (53, "param")  ## parameter declaration
    ConstY = (54, "const")  ## const variable declaration
    ResultY = (55, "result")  ## result variable declaration
    LetY = (56, "let")  ## let variable declaration
    CursorY = (57, "cursor")  ## cursor variable declaration
    TypevarY = (58, "typevar")  ## type variable declaration
    EfldY = (59, "efld")  ## enum field declaration
    FldY = (60, "fld")  ## field declaration
    ProcY = (61, "proc")  ## proc declaration
    FuncY = (62, "func")  ## function declaration
    IteratorY = (63, "iterator")  ## iterator declaration
    ConverterY = (64, "converter")  ## converter declaration
    MethodY = (65, "method")  ## method declaration
    MacroY = (66, "macro")  ## macro declaration
    TemplateY = (67, "template")  ## template declaration
    TypeY = (68, "type")  ## type declaration
    BlockY = (69, "block")  ## block declaration
    ModuleY = (70, "module")  ## module declaration
    CchoiceY = (71, "cchoice")  ## closed choice

proc rawTagIsNimonySym*(raw: uint32): bool {.inline.} =
  raw >= 52'u32 and raw <= 71'u32

type
  ControlFlowKind* = enum
    NoControlFlow
    IteF = (145, "ite")  ## if-then-else
    GraphF = (146, "graph")  ## disjoint subgraph annotation
    ForbindF = (147, "forbind")  ## bindings for a `for` loop but the loop itself is mapped to gotos
    KillF = (148, "kill")  ## some.var is about to disappear (scope exit)

proc rawTagIsControlFlowKind*(raw: uint32): bool {.inline.} =
  raw >= 145'u32 and raw <= 148'u32

