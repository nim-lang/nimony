# Generated by tools/gen_tags.nim from doc/tags.md. DO NOT EDIT!

import tags

type
  NimonyExpr* = enum
    NoExpr
    ErrX = (1, "err")  ## indicates an error
    SufX = (2, "suf")  ## literal with suffix annotation
    AtX = (3, "at")  ## array indexing operation
    DerefX = (4, "deref")  ## pointer deref operation
    DotX = (5, "dot")  ## object field selection
    PatX = (6, "pat")  ## pointer indexing operation
    ParX = (7, "par")  ## syntactic parenthesis
    AddrX = (8, "addr")  ## address of operation
    NilX = (9, "nil")  ## nil pointer value
    InfX = (10, "inf")  ## positive infinity floating point value
    NeginfX = (11, "neginf")  ## negative infinity floating point value
    NanX = (12, "nan")  ## NaN floating point value
    FalseX = (13, "false")  ## boolean `false` value
    TrueX = (14, "true")  ## boolean `true` value
    AndX = (15, "and")  ## boolean `and` operation
    OrX = (16, "or")  ## boolean `or` operation
    XorX = (17, "xor")  ## boolean `xor` operation
    NotX = (18, "not")  ## boolean `not` operation
    NegX = (19, "neg")  ## negation operation
    SizeofX = (20, "sizeof")  ## `sizeof` operation
    AlignofX = (21, "alignof")  ## `alignof` operation
    OffsetofX = (22, "offsetof")  ## `offsetof` operation
    OconstrX = (23, "oconstr")  ## object constructor
    AconstrX = (24, "aconstr")  ## array constructor
    BracketX = (25, "bracket")  ## untyped array constructor
    CurlyX = (26, "curly")  ## untyped set constructor
    CurlyatX = (27, "curlyat")  ## curly expression `a{i}`
    AddX = (30, "add")
    SubX = (31, "sub")
    MulX = (32, "mul")
    DivX = (33, "div")
    ModX = (34, "mod")
    ShrX = (35, "shr")
    ShlX = (36, "shl")
    BitandX = (37, "bitand")
    BitorX = (38, "bitor")
    BitxorX = (39, "bitxor")
    BitnotX = (40, "bitnot")
    EqX = (41, "eq")
    NeqX = (42, "neq")
    LeX = (43, "le")
    LtX = (44, "lt")
    CastX = (45, "cast")  ## `cast` operation
    ConvX = (46, "conv")  ## type conversion
    CallX = (47, "call")  ## call operation
    CmdX = (48, "cmd")  ## command operation
    CchoiceX = (74, "cchoice")  ## closed choice
    OchoiceX = (75, "ochoice")  ## open choice
    PragmaxX = (130, "pragmax")  ## pragma expressions
    QuotedX = (207, "quoted")  ## name in backticks
    HderefX = (208, "hderef")  ## hidden pointer deref operation
    DdotX = (209, "ddot")  ## deref dot
    HaddrX = (210, "haddr")  ## hidden address of operation
    NewrefX = (211, "newref")  ## Nim's `new` magic proc that allocates a `ref T`
    NewobjX = (212, "newobj")  ## new object constructor
    TupX = (213, "tup")  ## untyped tuple constructor
    TupconstrX = (214, "tupconstr")  ## tuple constructor
    SetconstrX = (215, "setconstr")  ## set constructor
    TabconstrX = (216, "tabconstr")  ## table constructor
    AshrX = (217, "ashr")
    OconvX = (218, "oconv")  ## object conversion
    HconvX = (219, "hconv")  ## hidden basic type conversion
    DconvX = (220, "dconv")  ## conversion between `distinct` types
    CallstrlitX = (221, "callstrlit")
    InfixX = (222, "infix")
    PrefixX = (223, "prefix")
    HcallX = (224, "hcall")  ## hidden converter call
    CompilesX = (225, "compiles")
    DeclaredX = (226, "declared")
    DefinedX = (227, "defined")
    HighX = (228, "high")
    LowX = (229, "low")
    TypeofX = (230, "typeof")
    UnpackX = (231, "unpack")
    EnumtostrX = (232, "enumtostr")
    IsmainmoduleX = (233, "ismainmodule")
    DefaultobjX = (234, "defaultobj")
    DefaulttupX = (235, "defaulttup")
    ExprX = (236, "expr")
    DoX = (237, "do")  ## `do` expression
    ArratX = (238, "arrat")
    TupatX = (239, "tupat")
    PlussetX = (240, "plusset")
    MinussetX = (241, "minusset")
    MulsetX = (242, "mulset")
    XorsetX = (243, "xorset")
    EqsetX = (244, "eqset")
    LesetX = (245, "leset")
    LtsetX = (246, "ltset")
    InsetX = (247, "inset")
    CardX = (248, "card")
    EmoveX = (249, "emove")
    DestroyX = (250, "destroy")
    DupX = (251, "dup")
    CopyX = (252, "copy")
    WasmovedX = (253, "wasmoved")
    SinkhX = (254, "sinkh")
    TraceX = (255, "trace")

proc rawTagIsNimonyExpr*(raw: TagEnum): bool {.inline.} =
  raw in {ErrTagId, SufTagId, AtTagId, DerefTagId, DotTagId, PatTagId, ParTagId, AddrTagId, NilTagId, InfTagId, NeginfTagId, NanTagId, FalseTagId, TrueTagId, AndTagId, OrTagId, XorTagId, NotTagId, NegTagId, SizeofTagId, AlignofTagId, OffsetofTagId, OconstrTagId, AconstrTagId, BracketTagId, CurlyTagId, CurlyatTagId, AddTagId, SubTagId, MulTagId, DivTagId, ModTagId, ShrTagId, ShlTagId, BitandTagId, BitorTagId, BitxorTagId, BitnotTagId, EqTagId, NeqTagId, LeTagId, LtTagId, CastTagId, ConvTagId, CallTagId, CmdTagId, CchoiceTagId, OchoiceTagId, PragmaxTagId, QuotedTagId, HderefTagId, DdotTagId, HaddrTagId, NewrefTagId, NewobjTagId, TupTagId, TupconstrTagId, SetconstrTagId, TabconstrTagId, AshrTagId, OconvTagId, HconvTagId, DconvTagId, CallstrlitTagId, InfixTagId, PrefixTagId, HcallTagId, CompilesTagId, DeclaredTagId, DefinedTagId, HighTagId, LowTagId, TypeofTagId, UnpackTagId, EnumtostrTagId, IsmainmoduleTagId, DefaultobjTagId, DefaulttupTagId, ExprTagId, DoTagId, ArratTagId, TupatTagId, PlussetTagId, MinussetTagId, MulsetTagId, XorsetTagId, EqsetTagId, LesetTagId, LtsetTagId, InsetTagId, CardTagId, EmoveTagId, DestroyTagId, DupTagId, CopyTagId, WasmovedTagId, SinkhTagId, TraceTagId}

type
  NimonyStmt* = enum
    NoStmt
    CallS = (47, "call")  ## call operation
    CmdS = (48, "cmd")  ## command operation
    GvarS = (51, "gvar")  ## global variable declaration
    TvarS = (52, "tvar")  ## thread local variable declaration
    VarS = (53, "var")  ## variable declaration
    ConstS = (55, "const")  ## const variable declaration
    ResultS = (56, "result")  ## result variable declaration
    GletS = (57, "glet")  ## global let variable declaration
    TletS = (58, "tlet")  ## thread local let variable declaration
    LetS = (59, "let")  ## let variable declaration
    CursorS = (60, "cursor")  ## cursor variable declaration
    ProcS = (64, "proc")  ## proc declaration
    FuncS = (65, "func")  ## function declaration
    IteratorS = (66, "iterator")  ## iterator declaration
    ConverterS = (67, "converter")  ## converter declaration
    MethodS = (68, "method")  ## method declaration
    MacroS = (69, "macro")  ## macro declaration
    TemplateS = (70, "template")  ## template declaration
    TypeS = (71, "type")  ## type declaration
    BlockS = (72, "block")  ## block declaration
    EmitS = (76, "emit")  ## emit statement
    AsgnS = (77, "asgn")  ## assignment statement
    ScopeS = (78, "scope")  ## explicit scope annotation, like `stmts`
    IfS = (79, "if")  ## if statement header
    WhenS = (80, "when")  ## when statement header
    BreakS = (84, "break")  ## `break` statement
    ContinueS = (85, "continue")  ## `continue` statement
    ForS = (86, "for")  ## for statement
    WhileS = (87, "while")  ## `while` statement
    CaseS = (88, "case")  ## `case` statement
    RetS = (92, "ret")  ## `return` instruction
    YldS = (93, "yld")  ## yield statement
    StmtsS = (94, "stmts")  ## list of statements
    PragmasS = (129, "pragmas")  ## begin of pragma section
    InclS = (136, "incl")  ## `#include` statement or `incl` set operation
    ExclS = (137, "excl")  ## `excl` set operation
    IncludeS = (138, "include")  ## `include` statement
    ImportS = (139, "import")  ## `import` statement
    ImportasS = (140, "importas")  ## `import as` statement
    FromimportS = (141, "fromimport")  ## `from import` statement
    ImportexceptS = (142, "importexcept")  ## `importexcept` statement
    ExportS = (143, "export")  ## `export` statement
    ExportexceptS = (145, "exportexcept")  ## `exportexcept` statement
    CommentS = (146, "comment")  ## `comment` statement
    DiscardS = (147, "discard")  ## `discard` statement
    TryS = (148, "try")  ## `try` statement
    RaiseS = (149, "raise")  ## `raise` statement
    UnpackdeclS = (160, "unpackdecl")  ## unpack var/let/const declaration
    StaticstmtS = (257, "staticstmt")  ## `static` statement
    BindS = (258, "bind")  ## `bind` statement
    MixinS = (259, "mixin")  ## `mixin` statement
    UsingS = (260, "using")  ## `using` statement
    AsmS = (261, "asm")  ## `asm` statement
    DeferS = (262, "defer")  ## `defer` statement

proc rawTagIsNimonyStmt*(raw: TagEnum): bool {.inline.} =
  raw in {CallTagId, CmdTagId, GvarTagId, TvarTagId, VarTagId, ConstTagId, ResultTagId, GletTagId, TletTagId, LetTagId, CursorTagId, ProcTagId, FuncTagId, IteratorTagId, ConverterTagId, MethodTagId, MacroTagId, TemplateTagId, TypeTagId, BlockTagId, EmitTagId, AsgnTagId, ScopeTagId, IfTagId, WhenTagId, BreakTagId, ContinueTagId, ForTagId, WhileTagId, CaseTagId, RetTagId, YldTagId, StmtsTagId, PragmasTagId, InclTagId, ExclTagId, IncludeTagId, ImportTagId, ImportasTagId, FromimportTagId, ImportexceptTagId, ExportTagId, ExportexceptTagId, CommentTagId, DiscardTagId, TryTagId, RaiseTagId, UnpackdeclTagId, StaticstmtTagId, BindTagId, MixinTagId, UsingTagId, AsmTagId, DeferTagId}

type
  NimonyType* = enum
    NoType
    ErrT = (1, "err")  ## indicates an error
    AtT = (3, "at")  ## array indexing operation
    AndT = (15, "and")  ## boolean `and` operation
    OrT = (16, "or")  ## boolean `or` operation
    NotT = (18, "not")  ## boolean `not` operation
    IteratorT = (66, "iterator")  ## iterator declaration
    ParamsT = (95, "params")  ## list of proc parameters, also used as a "proc type"
    ObjectT = (97, "object")  ## object type declaration
    EnumT = (98, "enum")  ## enum type declaration
    ProctypeT = (99, "proctype")  ## proc type declaration (soon obsolete, use params instead)
    IT = (104, "i")  ## `int` builtin type
    UT = (105, "u")  ## `uint` builtin type
    FT = (106, "f")  ## `float` builtin type
    CT = (107, "c")  ## `char` builtin type
    BoolT = (108, "bool")  ## `bool` builtin type
    VoidT = (109, "void")  ## `void` return type
    PtrT = (110, "ptr")  ## `ptr` type contructor
    ArrayT = (111, "array")  ## `array` type constructor
    VarargsT = (126, "varargs")  ## `varargs` proc annotation
    StaticT = (153, "static")  ## `static` type or annotation
    TupleT = (163, "tuple")  ## `tuple` type
    OnumT = (164, "onum")  ## enum with holes type
    RefT = (165, "ref")  ## `ref` type
    MutT = (166, "mut")  ## `mut` type
    OutT = (167, "out")  ## `out` type
    LentT = (168, "lent")  ## `lent` type
    SinkT = (169, "sink")  ## `sink` type
    NiltT = (170, "nilt")  ## `nilt` type
    ConceptT = (171, "concept")  ## `concept` type
    DistinctT = (172, "distinct")  ## `distinct` type
    ItertypeT = (173, "itertype")  ## `itertype` type
    RangetypeT = (174, "rangetype")  ## `rangetype` type
    UarrayT = (175, "uarray")  ## `uarray` type
    SetT = (176, "set")  ## `set` type
    AutoT = (177, "auto")  ## `auto` type
    SymkindT = (178, "symkind")  ## `symkind` type
    TypekindT = (179, "typekind")  ## `typekind` type
    TypedescT = (180, "typedesc")  ## `typedesc` type
    UntypedT = (181, "untyped")  ## `untyped` type
    TypedT = (182, "typed")  ## `typed` type
    CstringT = (183, "cstring")  ## `cstring` type
    PointerT = (184, "pointer")  ## `pointer` type
    OrdinalT = (185, "ordinal")  ## `ordinal` type

proc rawTagIsNimonyType*(raw: TagEnum): bool {.inline.} =
  raw in {ErrTagId, AtTagId, AndTagId, OrTagId, NotTagId, IteratorTagId, ParamsTagId, ObjectTagId, EnumTagId, ProctypeTagId, ITagId, UTagId, FTagId, CTagId, BoolTagId, VoidTagId, PtrTagId, ArrayTagId, VarargsTagId, StaticTagId, TupleTagId, OnumTagId, RefTagId, MutTagId, OutTagId, LentTagId, SinkTagId, NiltTagId, ConceptTagId, DistinctTagId, ItertypeTagId, RangetypeTagId, UarrayTagId, SetTagId, AutoTagId, SymkindTagId, TypekindTagId, TypedescTagId, UntypedTagId, TypedTagId, CstringTagId, PointerTagId, OrdinalTagId}

type
  NimonyOther* = enum
    NoSub
    KvU = (28, "kv")  ## key-value pair
    VvU = (29, "vv")  ## value-value pair (used for explicitly named arguments in function calls)
    RangeU = (49, "range")  ## `(range a b)` construct
    RangesU = (50, "ranges")
    ParamU = (54, "param")  ## parameter declaration
    TypevarU = (61, "typevar")  ## type variable declaration
    EfldU = (62, "efld")  ## enum field declaration
    FldU = (63, "fld")  ## field declaration
    ElifU = (81, "elif")  ## pair of (condition, action)
    ElseU = (82, "else")  ## `else` action
    TypevarsU = (83, "typevars")  ## type variable/generic parameters
    OfU = (89, "of")  ## `of` branch within a `case` statement
    ParamsU = (95, "params")  ## list of proc parameters, also used as a "proc type"
    PragmasU = (129, "pragmas")  ## begin of pragma section
    UnpackflatU = (158, "unpackflat")  ## unpack into flat variable list
    UnpacktupU = (159, "unpacktup")  ## unpack tuple
    ExceptU = (161, "except")  ## except subsection
    FinU = (162, "fin")  ## finally subsection

proc rawTagIsNimonyOther*(raw: TagEnum): bool {.inline.} =
  raw in {KvTagId, VvTagId, RangeTagId, RangesTagId, ParamTagId, TypevarTagId, EfldTagId, FldTagId, ElifTagId, ElseTagId, TypevarsTagId, OfTagId, ParamsTagId, PragmasTagId, UnpackflatTagId, UnpacktupTagId, ExceptTagId, FinTagId}

type
  NimonyPragma* = enum
    NoPragma
    EmitP = (76, "emit")  ## emit statement
    InlineP = (123, "inline")  ## `inline` proc annotation
    NoinlineP = (124, "noinline")  ## `noinline` proc annotation
    VarargsP = (126, "varargs")  ## `varargs` proc annotation
    SelectanyP = (128, "selectany")
    AlignP = (131, "align")
    BitsP = (132, "bits")
    NodeclP = (135, "nodecl")  ## `nodecl` annotation
    RaisesP = (151, "raises")  ## proc annotation
    UntypedP = (181, "untyped")  ## `untyped` type
    MagicP = (186, "magic")  ## `magic` pragma
    ImportcP = (187, "importc")  ## `importc` pragma
    ImportcppP = (188, "importcpp")  ## `importcpp` pragma
    ExportcP = (189, "exportc")  ## `exportc` pragma
    HeaderP = (190, "header")  ## `header` pragma
    ThreadvarP = (191, "threadvar")  ## `threadvar` pragma
    GlobalP = (192, "global")  ## `global` pragma
    DiscardableP = (193, "discardable")  ## `discardable` pragma
    NoreturnP = (194, "noreturn")  ## `noreturn` pragma
    BorrowP = (195, "borrow")  ## `borrow` pragma
    NoSideEffectP = (196, "noSideEffect")  ## `noSideEffect` pragma
    NodestroyP = (197, "nodestroy")  ## `nodestroy` pragma
    PluginP = (198, "plugin")  ## `plugin` pragma
    BycopyP = (199, "bycopy")  ## `bycopy` pragma
    ByrefP = (200, "byref")  ## `byref` pragma
    NoinitP = (201, "noinit")  ## `noinit` pragma
    RequiresP = (202, "requires")  ## `requires` pragma
    EnsuresP = (203, "ensures")  ## `ensures` pragma
    BuildP = (204, "build")  ## `build` pragma
    StringP = (205, "string")  ## `string` pragma
    ViewP = (206, "view")  ## `view` pragma
    InjectP = (266, "inject")  ## `inject` pragma
    GensymP = (267, "gensym")  ## `gensym` pragma
    ErrorP = (268, "error")  ## `error` pragma

proc rawTagIsNimonyPragma*(raw: TagEnum): bool {.inline.} =
  raw in {EmitTagId, InlineTagId, NoinlineTagId, VarargsTagId, SelectanyTagId, AlignTagId, BitsTagId, NodeclTagId, RaisesTagId, UntypedTagId, MagicTagId, ImportcTagId, ImportcppTagId, ExportcTagId, HeaderTagId, ThreadvarTagId, GlobalTagId, DiscardableTagId, NoreturnTagId, BorrowTagId, NoSideEffectTagId, NodestroyTagId, PluginTagId, BycopyTagId, ByrefTagId, NoinitTagId, RequiresTagId, EnsuresTagId, BuildTagId, StringTagId, ViewTagId, InjectTagId, GensymTagId, ErrorTagId}

type
  NimonySym* = enum
    NoSym
    GvarY = (51, "gvar")  ## global variable declaration
    TvarY = (52, "tvar")  ## thread local variable declaration
    VarY = (53, "var")  ## variable declaration
    ParamY = (54, "param")  ## parameter declaration
    ConstY = (55, "const")  ## const variable declaration
    ResultY = (56, "result")  ## result variable declaration
    GletY = (57, "glet")  ## global let variable declaration
    TletY = (58, "tlet")  ## thread local let variable declaration
    LetY = (59, "let")  ## let variable declaration
    CursorY = (60, "cursor")  ## cursor variable declaration
    TypevarY = (61, "typevar")  ## type variable declaration
    EfldY = (62, "efld")  ## enum field declaration
    FldY = (63, "fld")  ## field declaration
    ProcY = (64, "proc")  ## proc declaration
    FuncY = (65, "func")  ## function declaration
    IteratorY = (66, "iterator")  ## iterator declaration
    ConverterY = (67, "converter")  ## converter declaration
    MethodY = (68, "method")  ## method declaration
    MacroY = (69, "macro")  ## macro declaration
    TemplateY = (70, "template")  ## template declaration
    TypeY = (71, "type")  ## type declaration
    BlockY = (72, "block")  ## block declaration
    ModuleY = (73, "module")  ## module declaration
    CchoiceY = (74, "cchoice")  ## closed choice

proc rawTagIsNimonySym*(raw: TagEnum): bool {.inline.} =
  raw >= GvarTagId and raw <= CchoiceTagId

type
  HookKind* = enum
    NoHook
    DestroyH = (250, "destroy")
    DupH = (251, "dup")
    CopyH = (252, "copy")
    WasmovedH = (253, "wasmoved")
    SinkhH = (254, "sinkh")
    TraceH = (255, "trace")

proc rawTagIsHookKind*(raw: TagEnum): bool {.inline.} =
  raw >= DestroyTagId and raw <= TraceTagId

type
  ControlFlowKind* = enum
    NoControlFlow
    IteF = (154, "ite")  ## if-then-else
    GraphF = (155, "graph")  ## disjoint subgraph annotation
    ForbindF = (156, "forbind")  ## bindings for a `for` loop but the loop itself is mapped to gotos
    KillF = (157, "kill")  ## some.var is about to disappear (scope exit)

proc rawTagIsControlFlowKind*(raw: TagEnum): bool {.inline.} =
  raw >= IteTagId and raw <= KillTagId

