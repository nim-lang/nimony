# Generated by tools/gen_tags.nim from doc/tags.md. DO NOT EDIT!

type
  NimonyExpr* = enum
    NoExpr
    ErrX = (1, "err")  ## indicates an error
    SufX = (2, "suf")  ## literal with suffix annotation
    AtX = (3, "at")  ## array indexing operation
    DerefX = (4, "deref")  ## pointer deref operation
    DotX = (5, "dot")  ## object field selection
    PatX = (6, "pat")  ## pointer indexing operation
    ParX = (7, "par")  ## syntactic parenthesis
    AddrX = (8, "addr")  ## address of operation
    NilX = (9, "nil")  ## nil pointer value
    InfX = (10, "inf")  ## positive infinity floating point value
    NeginfX = (11, "neginf")  ## negative infinity floating point value
    NanX = (12, "nan")  ## NaN floating point value
    FalseX = (13, "false")  ## boolean `false` value
    TrueX = (14, "true")  ## boolean `true` value
    AndX = (15, "and")  ## boolean `and` operation
    OrX = (16, "or")  ## boolean `or` operation
    NotX = (17, "not")  ## boolean `not` operation
    NegX = (18, "neg")  ## negation operation
    SizeofX = (19, "sizeof")  ## `sizeof` operation
    AlignofX = (20, "alignof")  ## `alignof` operation
    OffsetofX = (21, "offsetof")  ## `offsetof` operation
    OconstrX = (22, "oconstr")  ## object constructor
    AconstrX = (23, "aconstr")  ## array constructor
    AddX = (25, "add")  ##
    SubX = (26, "sub")  ##
    MulX = (27, "mul")  ##
    DivX = (28, "div")  ##
    ModX = (29, "mod")  ##
    ShrX = (30, "shr")  ##
    ShlX = (31, "shl")  ##
    BitandX = (32, "bitand")  ##
    BitorX = (33, "bitor")  ##
    BitxorX = (34, "bitxor")  ##
    BitnotX = (35, "bitnot")  ##
    EqX = (36, "eq")  ##
    NeqX = (37, "neq")  ##
    LeX = (38, "le")  ##
    LtX = (39, "lt")  ##
    CastX = (40, "cast")  ##
    ConvX = (41, "conv")  ## type conversion
    CallX = (42, "call")  ## call operation
    QuotedX = (193, "quoted")  ## name in backticks
    HderefX = (194, "hderef")  ## hidden pointer deref operation
    DdotX = (195, "ddot")  ## deref dot
    HaddrX = (196, "haddr")  ## hidden address of operation
    NewoconstrX = (197, "newoconstr")  ## new object constructor
    TupleconstrX = (198, "tupleconstr")  ## tuple constructor
    SetX = (199, "set")  ## set constructor
    AshrX = (200, "ashr")  ##
    OconvX = (201, "oconv")  ## object conversion
    HconvX = (202, "hconv")  ## hidden basic type conversion
    DconvX = (203, "dconv")  ## conversion between `distinct` types
    CallstrlitX = (204, "callstrlit")  ##
    InfixX = (205, "infix")  ##
    PrefixX = (206, "prefix")  ##
    HcallX = (207, "hcall")  ## hidden converter call
    CompilesX = (208, "compiles")  ##
    DeclaredX = (209, "declared")  ##
    DefinedX = (210, "defined")  ##
    HighX = (211, "high")  ##
    LowX = (212, "low")  ##
    TypeofX = (213, "typeof")  ##
    UnpackX = (214, "unpack")  ##
    EnumtostrX = (215, "enumtostr")  ##
    IsmainmoduleX = (216, "ismainmodule")  ##
    DefaultobjX = (217, "defaultobj")  ##
    DefaulttupX = (218, "defaulttup")  ##
    ExprX = (219, "expr")  ##
    ArratX = (220, "arrat")  ##
    TupatX = (221, "tupat")  ##
    PlussetX = (222, "plusset")  ##
    MinussetX = (223, "minusset")  ##
    MulsetX = (224, "mulset")  ##
    XorsetX = (225, "xorset")  ##
    EqsetX = (226, "eqset")  ##
    LesetX = (227, "leset")  ##
    LtsetX = (228, "ltset")  ##
    InsetX = (229, "inset")  ##
    CardX = (230, "card")  ##
    EmoveX = (231, "emove")  ##
    DestroyX = (232, "destroy")  ##
    DupX = (233, "dup")  ##
    CopyX = (234, "copy")  ##
    WasmovedX = (235, "wasmoved")  ##
    SinkhX = (236, "sinkh")  ##
    TraceX = (237, "trace")  ##
  NimonyStmt* = enum
    NoStmt
    CallS = (42, "call")  ## call operation
    CmdS = (43, "cmd")  ## command operation
    VarS = (48, "var")  ## variable declaration
    ConstS = (50, "const")  ## const variable declaration
    ResultS = (51, "result")  ## result variable declaration
    LetS = (52, "let")  ## let variable declaration
    CursorS = (53, "cursor")  ## cursor variable declaration
    ProcS = (57, "proc")  ## proc declaration
    FuncS = (58, "func")  ## function declaration
    IteratorS = (59, "iterator")  ## iterator declaration
    ConverterS = (60, "converter")  ## converter declaration
    MethodS = (61, "method")  ## method declaration
    MacroS = (62, "macro")  ## macro declaration
    TemplateS = (63, "template")  ## template declaration
    TypeS = (64, "type")  ## type declaration
    BlockS = (65, "block")  ## block declaration
    ModuleS = (66, "module")  ## module declaration
    CchoiceS = (67, "cchoice")  ## closed choice
    EmitS = (68, "emit")  ## emit statement
    AsgnS = (69, "asgn")  ## assignment statement
    ScopeS = (70, "scope")  ## explicit scope annotation, like `stmts`
    IfS = (71, "if")  ## if statement header
    WhenS = (72, "when")  ## when statement header
    BreakS = (75, "break")  ## `break` statement
    ContinueS = (76, "continue")  ## `continue` statement
    ForS = (77, "for")  ## for statement
    WhileS = (78, "while")  ## `while` statement
    CaseS = (79, "case")  ## `case` statement
    RetS = (83, "ret")  ## `return` instruction
    YldS = (84, "yld")  ## yield statement
    StmtsS = (85, "stmts")  ## list of statements
    PragmasS = (118, "pragmas")  ## begin of pragma section
    InclS = (124, "incl")  ## `#include` statement or `incl` set operation
    ExclS = (125, "excl")  ## `excl` set operation
    IncludeS = (126, "include")  ## `include` statement
    ImportS = (127, "import")  ## `import` statement
    FromS = (128, "from")  ## `from` statement
    ImportexceptS = (129, "importexcept")  ## `importexcept` statement
    ExportS = (130, "export")  ## `export` statement
    CommentS = (131, "comment")  ## `comment` statement
    DiscardS = (132, "discard")  ## `discard` statement
    TryS = (133, "try")  ## `try` statement
    RaiseS = (134, "raise")  ## `raise` statement
  NimonyType* = enum
    NoType
    ErrT = (1, "err")  ## indicates an error
    AtT = (3, "at")  ## array indexing operation
    OrT = (16, "or")  ## boolean `or` operation
    NotT = (17, "not")  ## boolean `not` operation
    NegT = (18, "neg")  ## negation operation
    ParamsT = (86, "params")  ## list of proc parameters, also used as a "proc type"
    ObjectT = (88, "object")  ## object type declaration
    EnumT = (89, "enum")  ## enum type declaration
    ProctypeT = (90, "proctype")  ## proc type declaration (soon obsolete, use params instead)
    IT = (94, "i")  ## `int` builtin type
    UT = (95, "u")  ## `uint` builtin type
    FT = (96, "f")  ## `float` builtin type
    CT = (97, "c")  ## `char` builtin type
    BoolT = (98, "bool")  ## `bool` builtin type
    VoidT = (99, "void")  ## `void` return type
    PtrT = (100, "ptr")  ## `ptr` type contructor
    ArrayT = (101, "array")  ## `array` type constructor
    VarargsT = (115, "varargs")  ## `varargs` proc annotation
    StaticT = (138, "static")  ## `static` type or annotation
    RefobjT = (147, "refobj")  ## `ref object` type
    PtrobjT = (148, "ptrobj")  ## `ptr object` type
    TupleT = (149, "tuple")  ## `tuple` type
    OnumT = (150, "onum")  ## enum with holes type
    RefT = (151, "ref")  ## `ref` type
    MutT = (152, "mut")  ## `mut` type
    OutT = (153, "out")  ## `out` type
    LentT = (154, "lent")  ## `lent` type
    SinkT = (155, "sink")  ## `sink` type
    NiltT = (156, "nilt")  ## `nilt` type
    ConceptT = (157, "concept")  ## `concept` type
    DistinctT = (158, "distinct")  ## `distinct` type
    ItertypeT = (159, "itertype")  ## `itertype` type
    RangetypeT = (160, "rangetype")  ## `rangetype` type
    UarrayT = (161, "uarray")  ## `uarray` type
    OpenarrayT = (162, "openarray")  ## `openarray` type
    SettT = (163, "sett")  ## `sett` type
    AutoT = (164, "auto")  ## `auto` type
    SymkindT = (165, "symkind")  ## `symkind` type
    TypekindT = (166, "typekind")  ## `typekind` type
    TypedescT = (167, "typedesc")  ## `typedesc` type
    UntypedT = (168, "untyped")  ## `untyped` type
    TypedT = (169, "typed")  ## `typed` type
    CstringT = (170, "cstring")  ## `cstring` type
    PointerT = (171, "pointer")  ## `pointer` type
    OrdinalT = (172, "ordinal")  ## `ordinal` type
  NimonyOther* = enum
    NoSub
    KvU = (24, "kv")  ## key-value pair
    RangeU = (44, "range")  ## `(range a b)` construct
    RangesU = (45, "ranges")  ##
    ParamU = (49, "param")  ## parameter declaration
    TypevarU = (54, "typevar")  ## type variable declaration
    EfldU = (55, "efld")  ## enum field declaration
    FldU = (56, "fld")  ## field declaration
    ElifU = (73, "elif")  ## pair of (condition, action)
    ElseU = (74, "else")  ## `else` action
    OfU = (80, "of")  ## `of` branch within a `case` statement
    PragmasU = (118, "pragmas")  ## begin of pragma section
    UnpackflatU = (143, "unpackflat")  ## unpack into flat variable list
    UnpacktupU = (144, "unpacktup")  ## unpack tuple
    ExceptU = (145, "except")  ## except subsection
    FinU = (146, "fin")  ## finally subsection
  NimonyPragma* = enum
    NoPragma
    EmitP = (68, "emit")  ## emit statement
    InlineP = (112, "inline")  ## `inline` proc annotation
    NoinlineP = (113, "noinline")  ## `noinline` proc annotation
    VarargsP = (115, "varargs")  ## `varargs` proc annotation
    SelectanyP = (117, "selectany")  ##
    NodeclP = (123, "nodecl")  ## `nodecl` annotation
    RaisesP = (136, "raises")  ## proc annotation
    MagicP = (173, "magic")  ## `magic` pragma
    ImportcP = (174, "importc")  ## `importc` pragma
    ImportcppP = (175, "importcpp")  ## `importcpp` pragma
    ExportcP = (176, "exportc")  ## `exportc` pragma
    HeaderP = (177, "header")  ## `header` pragma
    ThreadvarP = (178, "threadvar")  ## `threadvar` pragma
    GlobalP = (179, "global")  ## `global` pragma
    DiscardableP = (180, "discardable")  ## `discardable` pragma
    NoreturnP = (181, "noreturn")  ## `noreturn` pragma
    BorrowP = (182, "borrow")  ## `borrow` pragma
    NoSideEffectP = (183, "noSideEffect")  ## `noSideEffect` pragma
    NodestroyP = (184, "nodestroy")  ## `nodestroy` pragma
    PluginP = (185, "plugin")  ## `plugin` pragma
    BycopyP = (186, "bycopy")  ## `bycopy` pragma
    ByrefP = (187, "byref")  ## `byref` pragma
    NoinitP = (188, "noinit")  ## `noinit` pragma
    RequiresP = (189, "requires")  ## `requires` pragma
    EnsuresP = (190, "ensures")  ## `ensures` pragma
    BuildP = (191, "build")  ## `build` pragma
    StringP = (192, "string")  ## `string` pragma
  NimonySym* = enum
    NoSym
    VarY = (48, "var")  ## variable declaration
    ParamY = (49, "param")  ## parameter declaration
    ConstY = (50, "const")  ## const variable declaration
    ResultY = (51, "result")  ## result variable declaration
    LetY = (52, "let")  ## let variable declaration
    CursorY = (53, "cursor")  ## cursor variable declaration
    TypevarY = (54, "typevar")  ## type variable declaration
    EfldY = (55, "efld")  ## enum field declaration
    FldY = (56, "fld")  ## field declaration
    ProcY = (57, "proc")  ## proc declaration
    FuncY = (58, "func")  ## function declaration
    IteratorY = (59, "iterator")  ## iterator declaration
    ConverterY = (60, "converter")  ## converter declaration
    MethodY = (61, "method")  ## method declaration
    MacroY = (62, "macro")  ## macro declaration
    TemplateY = (63, "template")  ## template declaration
    TypeY = (64, "type")  ## type declaration
    BlockY = (65, "block")  ## block declaration
    ModuleY = (66, "module")  ## module declaration
    CchoiceY = (67, "cchoice")  ## closed choice
  ControlFlowKind* = enum
    NoControlFlow
    IteF = (139, "ite")  ## if-then-else
    GraphF = (140, "graph")  ## disjoint subgraph annotation
    ForbindF = (141, "forbind")  ## bindings for a `for` loop but the loop itself is mapped to gotos
    KillF = (142, "kill")  ## some.var is about to disappear (scope exit)
