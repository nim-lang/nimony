#       Nimony Compiler
# (c) Copyright 2024-2025 Andreas Rumpf
#
# See the file "license.txt", included in this
# distribution, for details about the copyright.

## Macro plugin support - generates and compiles macro plugins,
## and provides infrastructure for macro invocation.

import std/[syncio, os, osproc, tables, strutils, hashes]

import ".." / lib / [nifstreams, nifcursors, nifbuilder, lineinfos, bitabs]
import nimony_model, decls, programs, renderer

type
  MacroPlugin* = object
    exePath*: string
    sourceHash*: string

  MacroPluginTable* = Table[SymId, MacroPlugin]

proc hash(s: SymId): Hash {.borrow.}

proc cleanSymbolName(s: string): string =
  ## Extract clean name from a symbol (remove module suffix)
  let dotPos = s.find('.')
  if dotPos >= 0:
    result = s[0 ..< dotPos]
  else:
    result = s

proc generateMacroPluginSource*(macroDecl: Cursor; macroSym: SymId): string =
  ## Generate the Nim source code for a macro plugin.
  ## The generated code will:
  ## - Import std/macros
  ## - Define the macro implementation proc
  ## - Have a when isMainModule block that deserializes NIF, calls impl, serializes result

  let r = asRoutine(macroDecl, SkipInclBody)

  # Collect parameter info
  type ParamInfo = tuple[name: string, paramKind: string, isStatic: bool]
  var params: seq[ParamInfo] = @[]

  var p = r.params
  if p.kind != DotToken and p.substructureKind == ParamsU:
    inc p
    while p.kind != ParRi:
      if p.substructureKind == ParamU:
        var param = p
        inc param  # skip (param

        var paramName = ""
        if param.kind == SymbolDef:
          paramName = cleanSymbolName(pool.syms[param.symId])
          inc param

        skip param  # skip export marker

        var paramKind = "untyped"
        var isStatic = false
        if param.kind == ParLe:
          let tk = param.typeKind
          case tk
          of UntypedT: paramKind = "untyped"
          of TypedT: paramKind = "typed"
          of TypedescT: paramKind = "typedesc"
          of StaticT:
            paramKind = "static"
            isStatic = true
          else: paramKind = "typed"

        if paramName.len > 0:
          params.add (paramName, paramKind, isStatic)
      skip p

  # Get macro name
  let macroName = cleanSymbolName(pool.syms[macroSym])

  # Render the macro body back to Nim code
  let bodyNimCode = asNimCode(r.body)

  # Build the generated source
  result = "# Auto-generated macro plugin for: " & macroName & "\n"
  result.add "# DO NOT EDIT - this file is generated by the Nimony compiler\n\n"
  result.add "import std/macros\n\n"

  # Generate the implementation proc
  result.add "proc " & macroName & "Impl("
  for i, (name, kind, isStatic) in params:
    if i > 0: result.add "; "
    if isStatic:
      # For static params, we receive the actual value
      result.add name & ": auto"  # TODO: proper type
    else:
      result.add name & ": NimNode"
  result.add "): NimNode =\n"

  # Indent the body
  for line in bodyNimCode.splitLines():
    result.add "  " & line & "\n"

  result.add "\n"

  # Generate the main block
  result.add "when isMainModule:\n"
  result.add "  # Load input NIF (macro arguments)\n"
  result.add "  let input = loadInput()\n"
  result.add "  \n"

  # Deserialize each parameter from the input
  result.add "  # The input is a stmts node containing the arguments\n"
  for i, (name, kind, isStatic) in params:
    if isStatic:
      # Static parameters need value deserialization - TODO
      result.add "  # TODO: static param deserialization\n"
      result.add "  let " & name & " = 0  # placeholder\n"
    else:
      result.add "  let " & name & " = input[" & $i & "]\n"

  result.add "  \n"
  result.add "  # Call the macro implementation\n"
  result.add "  let output = " & macroName & "Impl("
  for i, (name, _, _) in params:
    if i > 0: result.add ", "
    result.add name
  result.add ")\n"
  result.add "  \n"
  result.add "  # Save output NIF\n"
  result.add "  saveOutput(output)\n"

proc getMacroPluginPath*(nifcachePath: string; macroSym: SymId): string =
  ## Get the path to the compiled macro plugin binary
  let symName = pool.syms[macroSym]
  var cleanName = ""
  for ch in symName:
    if ch in {'a'..'z', 'A'..'Z', '0'..'9', '_'}:
      cleanName.add ch
    else:
      cleanName.add '_'
  result = nifcachePath / "macro_" & cleanName
  when defined(windows):
    result.add ".exe"

proc compileMacroPlugin*(nifcachePath: string; macroDecl: Cursor; macroSym: SymId;
                         info: lineinfos.PackedLineInfo): string =
  ## Compile a macro into a plugin binary.
  ## Returns the path to the compiled binary, or empty string on error.
  let exePath = getMacroPluginPath(nifcachePath, macroSym)
  let sourcePath = exePath & "_src.nim"

  # Generate source
  let source = generateMacroPluginSource(macroDecl, macroSym)

  # Write source file
  writeFile(sourcePath, source)

  # Compile using the standard Nim compiler
  # We need to provide paths to:
  # - lib/ for std/macros and other std modules
  # - src/lib/ for nifreader, nifbuilder, etc. that macros.nim imports
  let nimonyRoot = getAppDir().parentDir()
  let libPath = nimonyRoot / "lib"
  let srcLibPath = nimonyRoot / "src" / "lib"

  let cmd = "nim c -d:release --hints:off -o:" & quoteShell(exePath) &
            " -p:" & quoteShell(libPath) &
            " -p:" & quoteShell(srcLibPath) &
            " " & quoteShell(sourcePath)

  let (output, exitCode) = execCmdEx(cmd)
  if exitCode != 0:
    echo "Error compiling macro plugin for '", cleanSymbolName(pool.syms[macroSym]), "':"
    echo output
    return ""

  result = exePath

proc runMacroPlugin*(nifcachePath: string; dest: var TokenBuf;
                     info: lineinfos.PackedLineInfo;
                     macroSym: SymId; args: TokenBuf): bool =
  ## Run a compiled macro plugin.
  ## Returns true on success.
  let exePath = getMacroPluginPath(nifcachePath, macroSym)

  if not fileExists(exePath):
    echo "Macro plugin not found: ", exePath
    return false

  # Create temp files for input/output
  let inputPath = nifcachePath / "macro_in_" & $macroSym.int & ".nif"
  let outputPath = nifcachePath / "macro_out_" & $macroSym.int & ".nif"

  writeFile(inputPath, toString(args))

  # Run the plugin
  let cmd = quoteShell(exePath) & " " & quoteShell(inputPath) & " " & quoteShell(outputPath)
  let (output, exitCode) = execCmdEx(cmd)

  if exitCode != 0:
    echo "Macro plugin execution failed:"
    echo output
    return false

  # Parse output NIF into dest
  var s = nifstreams.open(outputPath)
  try:
    parse s, dest, lineinfos.NoLineInfo
  finally:
    close s

  return true
