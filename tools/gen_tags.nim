
import std / [strutils, sets, sequtils]

proc toNimName(s: string; suffix: string): string =
  s[0].toUpperAscii & s.substr(1) & suffix

type
  EnumList = enum
    CallConv,
    NifcExpr, NifcStmt, NifcType, NifcOther, NifcPragma, NifcTypeQualifier, NifcSym,
    NimonyExpr, NimonyStmt, NimonyType, NimonyOther, NimonyPragma, NimonySym, ControlFlowKind,
    NifIndex

proc toSuffix(e: EnumList): (string, string) =
  case e
  of CallConv: ("", "NoCallConv")
  of NifcExpr: ("C", "NoExpr")
  of NifcStmt: ("S", "NoStmt")
  of NifcType: ("T", "NoType")
  of NifcOther: ("U", "NoSub")
  of NifcPragma: ("P", "NoPragma")
  of NifcTypeQualifier: ("Q", "NoQualifier")
  of NifcSym: ("Y", "NoSym")
  of NimonyExpr: ("X", "NoExpr")
  of NimonyStmt: ("S", "NoStmt")
  of NimonyType: ("T", "NoType")
  of NimonyOther: ("U", "NoSub")
  of NimonyPragma: ("P", "NoPragma")
  of NimonySym: ("Y", "NoSym")
  of ControlFlowKind: ("F", "NoControlFlow")
  of NifIndex: ("Idx", "NoIndexTag")

proc shortcutToEnumList(shortcut: string): set[EnumList] =
  case shortcut.strip()
  of "CC": {CallConv}
  of "C": {NifcExpr}
  of "X": {NimonyExpr}
  of "PP", "P": {NifcPragma, NimonyPragma}
  of "PPC", "PC": {NifcPragma}
  of "PN": {NimonyPragma}
  of "SN": {NimonyStmt}
  of "SC": {NifcStmt}
  of "SU": {NifcOther, NimonyOther}
  of "SUC": {NifcOther}
  of "SUN": {NimonyOther}
  of "TQC": {NifcTypeQualifier}
  of "TC": {NifcType}
  of "TN": {NimonyType}
  of "IX": {NifIndex}
  of "Y": {NimonySym}
  of "G": {ControlFlowKind}
  of "Z": {NifcSym}
  else: raiseAssert "unknown enum descriptor: " & shortcut

const
  Header = "# Generated by tools/gen_tags.nim from doc/tags.md. DO NOT EDIT!\n"

type
  EnumField = object
    name: string
    tag: string
    value: int
    desc: string
  EnumImpls = array[EnumList, seq[EnumField]]

proc writeClassifier(f: File; e: EnumList; fields: seq[EnumField]) =
  var first = -1
  var last = -1
  var prev = -1
  var holes: seq[int] = @[]
  for f in fields:
    if first < 0: first = f.value
    if last < f.value: last = f.value
    if prev >= 0 and f.value != prev + 1:
      for h in prev + 1..f.value - 1:
        holes.add h
    prev = f.value
  f.write "\n\nproc rawTagIs" & $e & "*(raw: uint32): bool {.inline.} ="
  if holes.len <= 3:
    f.write "\n  raw >= " & $first & "'u32 and raw <= " & $last & "'u32"
    for h in holes:
      f.write " and raw != " & $h & "'u32"
    f.write "\n"
  else:
    f.write "\n  raw <= 255'u32 and raw.uint8 in {"
    var i = 0
    for field in fields:
      if i > 0: f.write ", "
      assert field.value >= 0 and field.value <= 255
      f.write $field.value & "'u8"
      inc i
    f.write "}\n"

proc writeModel(basename: string; data: EnumImpls; first, last: EnumList) =
  let f = open(basename & "_tags.nim", fmWrite)
  f.writeLine Header
  for e in first..last:
    f.write "\ntype"
    f.write "\n  " & $e & "* = enum"
    f.write "\n    " & toSuffix(e)[1]
    for field in data[e]:
      f.write "\n    " & field.name
      f.write " = (" & $field.value & ", " & field.tag & ")"
      if field.desc.len > 0:
        f.write "  ## " & field.desc
    writeClassifier(f, e, data[e])
  f.write "\n"

proc writeTagsFile(output: string; data: seq[(string, int)]) =
  let f = open(output, fmWrite)
  f.writeLine Header
  f.writeLine "const"
  f.writeLine "  TagData* = ["
  var i = 0
  for d in data:
    if i > 0: f.write ",\n"
    f.write "    (" & escape(d[0]) & ", " & $d[1] & ")"
    inc i
  f.writeLine "\n  ]"
  f.writeLine "const"
  for d in data:
    f.writeLine "  " & toNimName(d[0], "TagId") & "* = " & $d[1]

proc genTags(inp: File) =
  var i = -2
  var enumDecls = default EnumImpls
  var tags: seq[(string, int)] = @[]
  var knownTags = initHashSet[string]()
  for line in lines(inp):
    inc i
    if i <= 0: continue # skip header
    var parts = line.split("|")
    if parts.len == 0: continue
    if parts.len != 5:
      quit "WRONG LINE: " & line
    let tagName = parts[1].strip()
    if knownTags.containsOrIncl(tagName):
      quit "DUPLICATE TAG: " & tagName
    tags.add (tagName, i)

    let desc = parts[3].strip()
    let affectedEnums = parts[2].split(",")
    assert affectedEnums.len > 0
    for a in affectedEnums:
      for e in shortcutToEnumList(a):
        enumDecls[e].add EnumField(
          name: toNimName(tagName, toSuffix(e)[0]),
          tag: escape(tagName),
          value: i,
          desc: desc
        )

  writeTagsFile "src/models/tags.nim", tags

  writeModel "src/models/callconv", enumDecls, CallConv, CallConv
  writeModel "src/models/nifc", enumDecls, NifcExpr, NifcSym
  writeModel "src/models/nimony", enumDecls, NimonyExpr, ControlFlowKind
  writeModel "src/models/nifindex", enumDecls, NifIndex, NifIndex

proc main =
  var inp = open("doc/tags.md", fmRead)
  genTags(inp)
  inp.close()

main()
