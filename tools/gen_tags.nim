
import std / [strutils, sequtils]

proc toNimName(s: string; suffix: string): string =
  s[0].toUpperAscii & s.substr(1) & suffix

type
  EnumList = enum
    CallConv,
    NifcExpr, NifcStmt, NifcType, NifcOther, NifcPragma, NifcTypeQualifier,
    NimonyExpr, NimonyStmt, NimonyType, NimonyOther, NimonyPragma, NimonySym,
    NifIndex

proc toSuffix(e: EnumList): (string, string) =
  case e
  of CallConv: ("", "NoCallConv")
  of NifcExpr: ("C", "NoNifcExpr")
  of NifcStmt: ("S", "NoNifcStmt")
  of NifcType: ("T", "NoNifcType")
  of NifcOther: ("U", "NoNifcSubstructure")
  of NifcPragma: ("P", "NoNifcPragma")
  of NifcTypeQualifier: ("Q", "NoQualifier")
  of NimonyExpr: ("X", "NoExpr")
  of NimonyStmt: ("S", "NoStmt")
  of NimonyType: ("T", "NoType")
  of NimonyOther: ("U", "NoSub")
  of NimonyPragma: ("P", "NoPragma")
  of NimonySym: ("Y", "NoSym")
  of NifIndex: ("Idx", "NoIndexTag")

proc shortcutToEnumList(shortcut: string): set[EnumList] =
  case shortcut.strip()
  of "CC": {CallConv}
  of "C": {NifcExpr}
  of "X": {NimonyExpr}
  of "PP", "P": {NifcPragma, NimonyPragma}
  of "PPC", "PC": {NifcPragma}
  of "PN": {NimonyPragma}
  of "SN": {NimonyStmt}
  of "SC": {NifcStmt}
  of "SU": {NifcOther, NimonyOther}
  of "SUC": {NifcOther}
  of "TQC": {NifcTypeQualifier}
  of "TC": {NifcType}
  of "TN": {NimonyType}
  of "IX": {NifIndex}
  of "Y": {NimonySym}
  else: raiseAssert "unknown enum descriptor: " & shortcut

const
  Header = "# Generated by tools/gen_tags.nim from doc/tags.md. DO NOT EDIT!\n"

proc writeModel(basename: string; data: array[EnumList, string]; first, last: EnumList) =
  let f = open(basename & "_tags.nim", fmWrite)
  f.writeLine Header
  f.writeLine "type"
  for e in first..last:
    f.write "  " & $e & "* = enum"
    f.write "\n    " & toSuffix(e)[1]
    f.writeLine data[e]

proc writeTagsFile(output: string; data: seq[(string, int)]) =
  let f = open(output, fmWrite)
  f.writeLine Header
  f.writeLine "const"
  f.writeLine "  TagData* = ["
  var i = 0
  for d in data:
    if i > 0: f.write ",\n"
    f.write "    (" & escape(d[0]) & ", " & $d[1] & ")"
    inc i
  f.writeLine "\n  ]"
  f.writeLine "const"
  for d in data:
    f.writeLine "  " & toNimName(d[0], "TagId") & "* = " & $d[1]

proc genTags(inp: File) =
  var i = -2
  var enumDecls = default(array[EnumList, string])
  var tags: seq[(string, int)] = @[]
  for line in lines(inp):
    inc i
    if i <= 0: continue # skip header
    var parts = line.split("|")
    if parts.len == 0: continue
    if parts.len != 5:
      quit "WRONG LINE: " & line
    let tagName = parts[1].strip()
    tags.add (tagName, i)

    let desc = parts[3].strip()
    let affectedEnums = parts[2].split(",")
    assert affectedEnums.len > 0
    for a in affectedEnums:
      for e in shortcutToEnumList(a):
        enumDecls[e].add "\n    "
        let enumVal = toNimName(tagName, toSuffix(e)[0])
        enumDecls[e].add enumVal
        enumDecls[e].add " = (" & $i & ", " & escape(tagName) & ")"
        enumDecls[e].add "  ##"
        if desc.len > 0:
          enumDecls[e].add " " & desc

  writeTagsFile "src/models/tags.nim", tags

  writeModel "src/models/callconv", enumDecls, CallConv, CallConv
  writeModel "src/models/nifc", enumDecls, NifcExpr, NifcTypeQualifier
  writeModel "src/models/nimony", enumDecls, NimonyExpr, NimonySym
  writeModel "src/models/nifindex", enumDecls, NifIndex, NifIndex

proc main =
  var inp = open("doc/tags.md", fmRead)
  genTags(inp)
  inp.close()

main()
